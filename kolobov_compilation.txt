

Computer-science
    CISC и RISC архитектуры МП. ALU. register, transistor, System trigger. Прямой доступ к памяти. (DMA) Прерывание. Кэши L1, L2, L3, ОЗУ, swapping(Подкачка страниц)
    Кластер, SATA, IDE, HDD, SSD, RAID массив
    Гарвардская архитектура, Фон-Неймана(пристанская) архитектура
    Процес формализации: Машина Поста, Машина Тьюринга, Люмбда исчесления. (Как основа языков программирования)
    Парадигмы программирования: -Императивное программирование
                                -Декларативное программирование
                                -Структурное программирование
                                -Функциональное программирование (Монада, side effect, lambda, функция высшего порядка?)
                                -ООП (Класс, метод)
    Парадигмы ООП: Инкапсуляция, полиморфизм, наследование, абстракция.
    Принцыпы SOLID
    GoF Patterns (Порождающие, структурные, поведенчиские)
        Почему Singleton стал антипатерном. (Нарушение SRP, глобальный доступ, плохая тестируетмость, потоконебезопасность, десериализация...) Лучше использовать Factory

    GRASP Patterns
    JEE Patterns
        Различный подход к проектированию DAO или Repository (преимущество, Представление репозитория как коллекции)
        Спецификация (шаблон проектирования) простой предикат, который принимает объект бизнес-области и возвращает
        Active record (AR) — шаблон проектирования (Реализует MVC model, нарушает SRP)
        Data Mapper Перенос Model в БД (Типо entityManager)
        Front Controller

    С/С++: (Стоит копать глубоко (4-8 занятий только эти вещи))
        Размещение полей объекта в памяти
        Найти таблицу виртуальных методов (VTABLE),
        Написать свой allocator
        Трюки с адресной арифметикой
        Написать свой GC

    JSR (налог rfc в мире Java (JPA, JDBC, Servlet)) - определяется комитетом JCP

    Package principles (Принцыпы упаковки)
    Law of Demeter, LoD (Закон Деметры)
    loose coupling
    Kanban, Agile, Scrum, DevOps, Extreme Programming (XP)


    Git (https://learngitbranching.js.org/?locale=ru_RU)   (https://habr.com/ru/post/313890/)
        Директория .git/objects Создание графа. Хранения в виде дерева объектов (значит что хранятся только изменения)
        Блобы (git add) и деревья(commit)
        При коммите записывается (права доступа к файлу, что хранится в блобе, хэш блоба, имя файла)
        Ветки \то просты ссылки на определенный коммит
        HEAD - это символическое имя текущего выбранного коммита (HEAD всегда указывает на последний коммит из вашего локального дерева)
        git (add, commit, branch, checkout (head(commit), branch), merge, rebase, git branch -f, reset, revert, log)
        merge vs rebase
        Относительные ссылки в git (педдерживает чтобы )
        git checkout HEAD^ (каретка перемещает на родителя), тильда git checkout HEAD~4 (на кольичество шагов)
        ОСт команды (cherry-pick, )
        git flow, trunk based development.


    UML зависимости: (Асоциация частные случае: агрегация vs композиция)
    Чем композиция лучше наследования?
    Проблемы наследования (Наследование это не плохо просто надо соблюдать определенные правила. Во первых надо документировать. Но наследование продолжает недостатки. )

    Наследование проблема (Нарушает инкапсуляцию.)
        Зависимости UML;
    Подходы к спостроению приложения: Clean Architecture
    Микросервисы, манолит
    Enterprise software (EE)
    Паттерны по UML
    UML Ассоциация агрегация композиция генерализация(обобщение) реализация
    статическое и динамическое связывание


    Патерны (разница между прокси и декоратором)
    Шаблон Facade это когда у тебя есть сложная подсистема и с ней сложно работатьты создаешь другую штуку и тебе с ней легче рработать // пример конструктор у которого 20 аргументов и я создам 3 метода ты выбери название аргументов не надо. и еще пример У вас есть пакет там 100 класов никто не может запомнить как их использовать, создать клас newSimp а там от кого кому.



    Табулирование функции, callback (listaner) Callback -обратный вызов это передача исполняемого кода в качестве одного из параметров другого кода. qsort(1, sizeof()) В Java есть коллюэки. ,
    Массивы одномерные, двумерные, матрицы
    Прямой, обратный, дополнительный код.
    Рекурсия(хвостовая рекурсия, обход деревьев(в глубину, в ширину))
    Сортировка: bubble, select, insert, radix, quick, merge, heap
    Рекурсия vs Итеративность
    Асимптотическая сложность: Big O,
    overload vs override (инспекция кода);
    Сильная vs слабая типизация

    Алгоритмы:
            Префиксное дерево
            Транзиктивное замыкание (Теория множеств)

*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
JAVA база:
отношение has a (композиция) /is a (Композиция является одним из методов проектирования, который реализовывает отношение типа has-a в классах. Мы можем использовать наследование в Java или композицию для повторного использования кода. Композиция — более строгий тип связи. При использовании композиции объект не только является частью какого-то объекта, но и не может принадлежать другому объекту того же типа.))
    Реализации Java: от Oracle, RedHut
    RMI (Remote Method Invocation)
    pattern matching (instancee of java 14)
    strictfp модификатор, для чисел с плавающей точкой (будет вычесляться как в старых версиях)
    label (метка)
    << vs >> >>> shift) (разбераться с классами  Integer, Long для побитовых операций) | vs || & vs && % и Tree (Вопросы типа:  найти самый старший не нулевой бит, самый младший не нулевой бит)
    Лямбды и анонимные классы
    Побитовые операции: постфиксная, префиксная I++ ++I;
    Как передаются параметры по ссылке или по значению ((в java по значению))
    POJO, JavaBean, мутаторы, аксесоры, get, set, наличие деф конструктора;
    Ключевое слово new и null что это.
    Модификаторы доступа (Внешний, внутренний класс) (Модификатор доступа у внешнего класса не может быть protected)
    instanceOf, assert
    Базовые типы java (1 Reference + 8 primitive types = 9), unsigned типы в java: беззнаковый тип (unsigned ) char
    String, Integer имьютебл (как будто они сериализуют а потом десириализуют)
    Различие: Примитивов (Могут быть: stack, null) vs Оберток
    boxing/unboxing
    final (immutable/ mutable)
    effectively final (в stream) (если после её определения она не изменяется. Соответственно на Java 8 ваш код будет скомпилирован.)
    Захватывать из контекста анонимного класса внутри метода можно только финальные переменные? (Да)
    Reflection API, Рефлексия (Опрделание)
    Различие var arg (...) and Массивы []
    static class
    static vs final чем схожи (они оба модификаторы.  Модификаторы – это мощный инструмент для описания классов, их конструкторов, полей и методов, использование которого позволит более четко и правильно описывать поведение объектов.)
    на экземплре можно вызвать статический метод (при этом ссылка будет нулевая) (new Clazz().f(); или Object o = null; o.f(); если f() статический метод)
    Отличие interface (не иммет сосотяния, все поля final) от abstract class
        Абстрактный класс: иммеет конструтор (задать начальные значения), экземпляр создать нельзя, final не может быть
    Этапы инициализации: static {} блоки во всех наслдниках ->  {} блок инициализация (в одном классе) -> конструктор (в одном классе) :: и так поочередно в классе
    Отличие статических inner классов от нестатических
    this, super;
    Анотация нерекурентная структура данных, нельзя из них создать связанный список...
    Сериализация и десериализация (serializable/ externalizable) transient.
            Как создать экземпляр класса не используя конструктор. (Сериализация/дессериализация).
    Методы класса Object
        equals hashcode (Контракты, правила переопределения)
        clone (interface Cloneable) Почему: java.lang.CloneNotSupportedException (если не переопределить Cloneable)
        метод clone (interfase Cloneable) :: что будет если class T clone {/*без полей клонировть*/} будет exception если нет Cloneable;
        finalize vs System.gc()
    Виды ссылок: strong, java.lang.ref SoftReference, WeakReference, PhantomReference
    Интерфейсы маркеры: serializable, AutoCloseable, cloneable
    Интерфейсы Comparator (compare(T o1, T o2) vs comparable (int compareTo(T o), (class cast exception)
    Интерфейс Observer и паттерн
    Серриализация с наследованием (как сериализовать)
    Инстанц класса без конструктора (дессириализация)
    Stream и pipeline операции (каждыйй элеметн проежает через промежуточные операции и выполняет)
    Stream.forEach vs Iterable.forEach vs Stream.forEachOrdered (с порядком)
    Spliterator
    RX java (нет стримов это различные либы)
    Generic (Ковариантность и контравариантность), инварианты) Не использовать row типы, дженарифицировть хотябы знаком ? => List<?>
    Может ли быть 2 main метода (Да при наследовании и просто перегрузка)
    Разница между стек алокацией и хип алокацией
    Класс void в jdk
    Работа с кодировками
    Коллекции которых нет в JDK (хэшмапа ключи с двух сторон (jakarta apach commons))
    outOfmemmoryError // (утечка памяти ->GC задыхается от создания объектов)
    Профилировщик кучи
    интерфейс примясь -> mixin // (пример интерфейс Cloneable)
    Наименование параметров типа обычно состоит из одной буквы. Наиболее часто это одно из этих пяти: Т для произвольных типов, Е для типов элементов в коллекции, К и V для ключей и значений словаря, X для исключений. Последовательность произвольных типов может быть Т, U, V или Т1, Т2, ТЗ. Примеры типографических соглашений приведены в таблице:
    Регулярные выражения
    loadfactory || capacity
    виртуальная машина, JIT компилятор
    comparable classcastexceprion
    Отличие интерфейса, класса от абстрактного класса (у класса можно создать экземпляр)
    Интерфейсы маркеры (Раньше деалали интерфейсы маркеры сейчас в основном делают анотации, ранбше просто анотаций не было)
    Возвращать коллекцию null нельзя. Надо возращать пустую коллекцию.
    Одна из проблем JDK это то что в java не были определены еденицы времени, в некоторых местах object.wait() получает мили секунды, а вот system.nanotime наносекунды а все возвращает long и поэтому кто те использут мили секунды кто то нано... и поэтому в java util concuren впилили и везде пытаются впилить enum TimeUnit -> теперт принято что теперь указываем время и ед изм Пример в ExcecutorService (время, ед. измер)
    обобщённые типы — инвариантны и используют механизм стирания
    обычные /масивы ковариантны, рефецируемые? (Ответ: да)
    Как работает JWT
    Что такое  iss? Что храним в sub?
    Почему не стоит использовать параллельные стримы для  долгих операций?  потому что размер дефолтного fjp ограничен, и если потоки застрянут, вся система затормозит
    Вопрос про примитивы: == что будет если int 100 int 100 сравнить ==. (примитивы сравниваются по значению)
    Почему строка является популярным ключем в HashMap в Java? (Поскольку строки неизменны, их хэшкод кэшируется в момент создания, и не требует повторного пересчета. Это делает строки отличным кандидатом для ключа в Map и они обрабатываются быстрее, чем другие объекты-ключи HashMap. Вот почему строки преимущественно используются в качестве ключей HashMap.
    Порядок инициализации таков в java?
    String (как хранятся строки Строки являются неизменными, поэтому мы не можем изменить их значение в программе. Следовательно они потокобезопасные и могут благополучно использоваться в мультипоточном окружении. Как подсказывает название, пул строк – это набор строк, который хранится в памяти Java heap. Мы знаем, что String это специальный класс в Java, и мы можем создавать объекты этого класса, используя оператор new точно так же, как и создавать объекты, предоставляя значение строки в двойных кавычках.Пул строк возможен исключительно благодаря неизменяемости строк в Java и реализации идеи интернирования строк. Пул строк также является примером паттерна Приспособленец (Flyweight).Пул строк помогает экономить большой объем памяти, но с другой стороны создание строки занимает больше времени.)
    обработки ошибок fail-fast
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************


Клонирование (считается bad practies)объект котрый получиться дожен соотв нескольким требования:
1) x.clone() != x
2) x.clone().equals(x)
3) x.clone().getClass() == x.getClass();
Почему плохо клонирование: приватные поля, Data создания разная в клоне и в объекте, с финальными филдам(поле) не смогу в клони работать. Поэтому лучше через конструктор или методы...
CloneNotSupportedException => если не имплементировать Cloneable. Есть поверхностное и глубокое клонирование (Его используют в тех случаях, когда в клонируемом классе есть изменяемые объекты. Для глубокого копирования списка нужно пройтись по всем элементам и клонировать каждый. Естественно как говорил Головач то ссылка будет по итогу ссылаться на посл. элемент, поэтому можно выкручиваться рекурсией).

equals() переопределение должно быть 5 правил:
1) рефлексивным ---> x.equals(x) true // поломать можно в сосновном только если return random.boolean()
2)симетричным ---> x.equals(y) = y.equals(x) //
3)транситивным ---> x.equals(y) and y.equals(z) then z.equals(x). выполнение отношений aRb aRb и bRc bRc влечёт выполнение отношения  aRc.
4)консистентным--->не использовать параметры которые должны меняться, тоесть динамические поля пример переменая прочитаная из переменной среды, файлы настроек.
5)non-null. Не нул --->

hashcode() каждый раз при переопределении equals должны переопределять hashcode. Джошуа Блох говорит. В документации  говорится. Как переопределяется берется относительно большое число result = 17 которое делится только на себя и на еденицу.  result = 31 * result + i; .... для одного поля и так продолжать result = 31 * result + x; В hashcode должны использоваться исключительно те параметры которые используются в equals. И нельзя использовать значение котрые считаются на основании других значений.

*************************************************************************************************************************************************************************************
java 8
        Многопоточность: шаблон Producer consumer
        lambda, ссылка на метод (::), ссылка на констркутор (::new)
        Лямбды vs анонимные классы (Лямбды оптимальны)
    java 8 указатель на метод
    java 8 stream -> это что понять: filter и map потом flatMap; теперь надо брать задачу конкр и решать, решать не получается значит надо брать задачу решеную на другом языке, функциональном, и  пытаться решить ее;
    monada и none у float другое пространство //все на nono = nan(none) // Другое пространство от туда не вернуться

*************************************************************************************************************************************************************************************
String  Строки -> набор char[] естестввенно поянтьие char...
        Как были до java-8 и сейчас...
        Почему строка неизменная и финализированная в Java?
        Почему массив символов предпочтительнее строки для хранения пароля?
        Дайте определение понятию “пул строк”. ( String s = "s"  String s = new String("s");)
        String, char[], StringBuilder, StringBuffer различия


*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Exception
    Иерархия исключений (checked/unchecked)
    Сцепление исключений
    try с ресурсами (interface AutoCloseable)
    multi catch vs catch(Ex || Er)
    Checked (что бы компилятор подсказывал что надо обрабатывать ошибки)/unchecked
    RuntimeException (unchecked), Error (unchecked), (Throwable, Exception ->) checked
    throws, throw
    Создание исключения, унаследоваться от Exception
    Могли бы вы придумать ситуацию, когда блок finally не будет выполнен? (finally может не выполниться если в try {System.exit(0)} Остановка JVM.
    При return в try выполниться finally
    Потеря исключения
    Компилятор запретит обработать после Exception в след catch RuntimeExc Потому что по иерархии
    Как видет себя приложение при Error (В спеке сказано, что приложение будет вести себя не корректно. Перестанет работать.)
    Exception в static блоке что будет (Static block can throw only Runtime exception or can use a try-catch block to catch checked exception.) Типично в static Работаем с jdbc
    Потеря исключения (У Экеля много задачек на данную тему)
    Синхронный (Которые происходят в ответ на какоето действие (Делим два числа и получаем NullPointerException)) и асинхронный (Происходят сами по себе не в ответ на ваше дейвствие (OutOfMemmory Error, JVM подумала что ей не хватает памяти)) exception (Это класификация меньше известна чем checked/unchecked)
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Коллекции
    Нарисовать иерархию коллекций.
    Сложность различных алгоритмов;
    Большой упор на деревья.
    Сapacity различных коллекций (arrayList...);
    ArrayList vs LinkedList.
    Почему Map не наследуется от Collection?
    HashMap vs TreeMap vs HashTable vs LinkedHashMap
    Queue, Deque
    HashSet vs TreeSet
    Как получить коллекцию только для чтения
    Как сделать из одной коллекции другую
    Как сделать коллекцию синхронизированной
    Comparable и Comparator
    Почему коллекции не наследуют интерфейсы Cloneable и Serializable (Кроме ArrayList, LinkedList)
    Какие коллекции синхронизированы?
    Как получить не модифицируемую коллекцию?
    Что будет при вот таком вызове: new TreeMap().put(new Object(), new Object())
    Разрешение коллизий, различные варианты (метод цепочек, открытой адресации);
    Например скомпилируется ли такой код: Number[] arr = new Integer[5];  или такой List<T> list = new ArrayList<Integer>().
    В WeakHashMap используются WeakReferences. А почему бы не создать PhantomHashMap на PhantomReferences?
    интерфейс Comparator<T> и comparable
    iterator // forEach
       HashSet
                метод contains при том что hashcode будет возвращать return Random(). -> (нельзя так как у одинаковых объектов будет разнй хэшкод)
                а если hashcode вынести за пределы метода и возвращать final -> тогда он будет практически как базовый, на каждый новый экземпляр будет другой hashcode

       HashMap
                Как определяется index бакета у элемента? (index = hashCode(key) & (n-1))
                С java 8 при коллизии O = lg(n) если больше 8 элементов связанный список то преобразуется в setTree(TREEIFY_THRESHOLD ), раньше (до 8 Java) был связанный список только O = (n) за линейное время
                        Обратно пороговое значение для преобразования 6 элементов тогда из TreeSet будет опять односвязанный список (linked list)
                               TreeSet в HashMap не поддерживает одинаковых значейний (дупликатов) по КЛЮЧУ(KEY), по ЗНАЧЕНИЮ (VALUE) поддерживает
                               Сравнение идет всегда по key (hashcode and equals должны вычеслять по ниму)
                HshMap дает ли гарантию на порядок (НЕТ)
                Может ли содержать null (Да только один в качестве ключа, и много value = null)







    for Each (Нет счетчика)
        Почему эквивалентен обычному циклу в ArrayList, но не эквивалетен в LinkedList. Потому что O(1) vs O(n))
        next, hasNext, remove
        ConcurentModificationException
        Entry (set)
    Iterator (Iterable)


*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Потоки ввода/вывода, Кодировки
    Класс File
    Socket.
    InputStream, OutputStream, Reader, Writer
    RandomAccessFile
    FilenameFilter
    Какие классы позволяют архивировать объекты?
    Как работает Java NIO и почему оно лучше IO

*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Concurency
    Когда происходит HB Ребро
    Многопоточность полностью ортогонально ООП (Различает только shared переменные(Поля объектов, статические поля, элементы масива) и локальные переменные (локальн переменные, аргументы методов)// может быьт защищена как приватная в другом пакете.)
    JVM завершает работу когда завершают работу все потоки не демоны
    Когерентность кэша (cache coherence (CCP) на уровне железа не контролируют даже на asm)
    Инвалидность кэша
    Program order (частичный порядок)
    В спецификации нет обзе шкалы времени разных потоков (это сделано для оптимизации что бы каждый поток мог работать на своем ядре со своим кэшем и не влиял на другое)
    Кэши не причина, кэши это способ объеснить. Вообще есть спецификация и это достаточная причина.
    Пробрасывание данных без HB ребра может быть (из-за наличия кэшей)
    HB ребро (heppens-before-edge) (Есть пара событий в спецификации где определены действия которые позволяют добавить ребро )
    Установка отношения happen-before (запичь и чтение в volatile переменную)
    synchronizes-with отношение (список операци которые устанавливают данное отношение)
    data race
    Поток main не демон, все что он породил не демоны
    Блокировка Dekker lock (Декера) и блокировка Peterson lock
    Roach motel jmm
    Мониторы: synchronized (illegalMonitorStateException: wait, notify, notifyAll (можно вызывать когда захватили блокировку на том же самом объекте) )
    synchronized (При входе в лок и выходе unlock где другой поток лочится по тому же объекту образуется happen-before)
    java se 17 часть спецификации подробно о final и.т.п.
    Если Long и double не атомарны то может переслаться (32 бита т.е. 64 бита по частям)
    Должны быть атомарны i++, long, double
    RentrackLock более крутой synchronized по api
    Двухкратный захват монитора по synchronized не отличается от однократного
    mutex (mutual exclusion (взаимное исключение))
    В котексте выполнения статического метода указателя this не существует
    synchronized по разным мониторам вообще ни как не коррелируется
    spinlock
    Вкратце осознать (Fork/JOIN, Actor/ Akka, STM: multiverse CSP: JCSP)
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Вопросы wait и notify; что будет если wait, notify или notifyAll вызвать вне блока syncronized(java.lang.IllegalMonitorStateException)
Блок syncronized
volotile;
JMM модель памяти. HB ребра. Потоки демоны.
Атомарные операции.
Иммутабельные объекты.
Копи конструкторы
join, yeld/ мордификаторы volotile
Дайте определение понятию “взаимная блокировка”.
Чем отличаются методы interrupt, interrupted, isInterrupted?
Что такое ThreadGroup и зачем он нужен?
Что такое ThreadPool и зачем он нужен?
Что такое ThreadPoolExecutor и зачем он нужен?
Что такое Executor?
Что такое ExecutorService?
Зачем нужен ScheduledExecutorService?
Всякие стандартные примитивы синхронизации: CyclicBarrier, CountDownLatch, ReentrantLock, Semaphore, Exchanger, phaser(редкость спрашивают сложный)
Неблокирующие операции.
CAS loop;
Дедлоки
Singelton и volotile + с линивой инициализацией // Double Checked Locking...
Интерфейс Runnable vs Callable
i++ в многопотчке
Как работает Java NIO и почему оно лучше IO
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Stream
    Функции первого класса (В java нет, но типо  ->)
    lambda
    stream collection
    @FunctionalInterface
    Optional. Maybe
    Monada // - MonadaOptional послед вычеслений
    monoid, ассоциативные операции, нейтральный элемент
    Stream // paralelSteram
    Predicate

waildcards (   <? extend E>   ) в Generic когда мы что то получаем мы используем <extendds> когда возвращаем использум <super> и нельзя никогда в возвращаемом типе использовать wildcard. Правило PECS если какой то метод и нужно получить и сохранить данные то надо extend. А когда выдаем super. Пример принимаем в колекцию List<? extend E>; В возвращем типе нельзя использовать wildcard
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Garbage collector
        GC ( garbage collector)
        GC - как работает; (Раньше хип был разбит на сегменты по поколениям. И сборка происходила во всем сегменте. В G1 хип разбит на небольшие сегменты, которые могут относиться к любым поколениям, и сборка собирает стока сегментов, скока успеет за заданное время. Троупут выше, фиксированная пауза, но требует больше хипа и процессора для работы. Как там что в шенанде я не знаю. ")
        GC -Периодически спрашивали про сборщик мусора, но без тонких деталей. Рассказа об одном алгоритме его работы на поколениях было достаточно
        Shenandoah
        MetaSpace
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Струтуры данных

*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
JAVA EE:
REST vs SOAP vs HTTP vs HTTP2/0 vs WEB-SOKET
*************************************************************************************************************************************************************************************
JNDI (объект  с контекстом/ биндить/ работать с ними)
    Для чего. Где испльзуется. Lookup.
    Можно так же как DI инжектить с помощью анотации @Resource только это считается плохо.
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
JMS (Брокекры сообщений)
    Как отправить Message
    Брокеры
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Maven
     Для менеджмента проекта (например подключение библиотек...), для автоматической сборки. запускает jar, запускает тесты
     А что если закрыто подключение к Интернету. что с библиотеками
     Maven Central   (Должны как то обрубить входы что бы не качал репозитории с левых мест)

*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
JDBC (https://habr.com/ru/company/golovachcourses/blog/250971/)
    DDL  (Data Definition Language(CREATE, CREATE, DROP)) vs DML (Data Manipulation Language(SELECT, INSERT, UPDATE, DELETE))
                                    vs DCL (Data Control Language (привелегии доступа к БД)(GRANT, REVOKE)) vs TCL (Transaction Control Language(COMMIT, ROLLBACK, SAVEPOINT ))
    Транзакция — это N (N≥1) запросов к БД, которые выполнятся успешно все вместе или не выполнятся вовсе.
    JDBC API и JDBC Driver (Connector/J: JDBC Driver to MySQL) и ODBC (Open Database Connectivity)
    Statement vs PreparedStatement(Наследуется от Statement) vs CallableStatement(Наследуется от PreparedStatement)
    Этапы: Driver, DriverManager(Принимает разные драйверы), Connection, Statement.
    ResultSet Iterator, номер колонок с еденицы начинаентся (Поучение данных по resultSet в котором statement.executeQuery()),
    (statement:) execute, executeQuery, executeUpdate (SQL запросы)
    JDBC Batch Processing (возможность выполнить группу запросов за один раз)
    JDBC Transaction Management (commit, autocommit, rollback)
    Уровни изоляции транзакции. При выполнении 2ух транзакций параллельно. (READ_UNCOMMITTED (чтение незафиксированных данных (блокировка данных на время выполнения команды обновления)),
                    READ_COMMITTED (чтение фиксированных данных), REPETABLE_READ (повторяемость чтения), SERIALIZABLE (полностью изолированы, упорядочиваемость))
            Проблемы паралельного выполнения транзакции: dirty reads (чтение данных которые впоследствии не подтвердятся),
                        фантомное чтение (при одной и тойже выборки разные данные), неповторяющееся чтение (раннее прочитаные данные оказываются измененными), потерянное обнавление (при одновременном изменении одного блока данных)
    Типы чтения транзакции.(dirty, nonrepeatable, phantom reads)
    JDBC Savepoint («чекпоинты» в транзакции для отката)
    JDBC DataSource (Какие приимущества)
    JDBC пул соединений, JNDI(связывает объекты с properties(именами)) В JDBC
    ResultSet курсор (iterator (next, prev), first(), last(), на конкретную строку absolute(5), относительно текущего порядка relative(3))
    Можно воспользоваться раннее созданным ResultSet
    ResultSet Concurrency 2 уровня  CONCUR_READ_ONLY и CONCUR_UPDATABLE
    ResultSet: holdability (ResultSet позволит оставить открытым после неявных или явных коммитов)
    JDBC Savepoint (делает откат транзакции до точки сохранения, при rollback: Savepoint savepoint = null; con.rollback(savepoint) )
    JDBC Connection Pooling (пулл при connection, singleton начнет задыхаться при высокой нагрузке)
    SQLException
    DAO Pattern (Оперируем коллекцией, интерфейс (как абстракция) Пример (объект User) инкапсулирует доступ и и добавление логики т.е. есть сущность и есть CRUD)
    Active Record (Оперирует стройкой из БД или view (MVC) инкапсулирует доступ и и добавление логики)
    Repository просто более высокая абстракция (DDD Предметно-ориентированное программирование (DDD))
    Transaction Script (каждый раз создаем Statement)

*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
SQL
    Курсор на БД
    DBMS vs RDBMS (каждая RDBMS (таблицы, первичноый ключ) может являеться DBMC но не наоборот, DBMC хранит данные в файле (связи только иерархические, дети и потомки))
    SQL vs NoSQL
    join все виды
    Операция соединения (Реляционная алгебра)
    Логика первого порядка
    Первая нормальная форма (1НФ), реляционная база, уникальный ключ, кортеж.
    Sixth normal form (6 нормальных форм)
    Правила нормализации баз данных
    Денормализация БД
    Реляционное деление
    ACID
    Теорема CAP
    Как вы понимаете NULL, почему NULL нельзя прочесть как поле.
    Что такое Index. Почему нельзя все индексами сделать.
    Уровни изоляции транзакций (какой уровень какую проблему решает)
    Индексы - как хранятся, какие с ними могут быть проблемы и тд
    Пример что просят:: (Написать запросы обычно двух видов: 1 - есть таблица людей и таблица навыков и таблица связи многие ко многим. написать запрос, который вернет всех людей, которые НЕ знают джаву.  Ну или любая вариация запроса на left join.)
    Пример что просят:: (Сколько строк вернут разные виды джоинов, если ключи повторяются. Тут надо помнить, что джоин работает как декартово произведение.)
    NoSQL vs SQL
    Приимущества Mysql от Oracle... (В общем разное сравнение БД)
    Уметь писать запросы
    (На join и group by в основном. Что-то типа найди производителя машин с максимальной скоростью от 250 до 270 км/ч)
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Hibernate
    @Entity, @Basic, @Id и UUID, @Column
    load vs get (load использует Proxy и выбрасываект ObjectNotFoundException, а get просто вернет Null )
    Анотация @Formula (Данных не хранятся в БД а просто операция из других полей)
    @Embeddable (Отдельное поле Entity которое явл классом) и EmbeddedId(Поле в Entity будет id для Embedded )
    Access type (через field или гетеры)
    Анотация @Access (Через ревлексию field, property)
    Анотация @Transient (Не сохр в БД, можно и через ключевое слово)
    Отношение между классами(oneToOne, oneToMany, manyToOne, ManyToMany) одностороннее и двустороннее отношение
    N+1 проблема ()
    Стратегии наследования (3 из JPA (single_table, Joined, table_per_class)и 1 из Hibernate (@MappedSuperclass (суперкласс для остальных типо id переопределить можно)))
    Состояние Entity (transient(new) -> (save() or persist() hibernate знает о ней)-> ... (managed or persistent) -> detached(у hibernate могут быть свои данные) -> removed )
    Оптимистические и писсимистические локи (Поле version, @Version) Hibernate
    Proxy pattern for Lazy load?
    BaseEntity (@MappedSuperclass)
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Spring
    IoC, IoC через фабрики, какие плюсы и минусы, через DI какие плюсы и минусы
    Деклоротивное программировнаие
    IoC (DI) vs фабрика
    IoC контейнер (Мапа <Id bean, Bean>)
    Жизненный цикл бина
    Область действия компонента (бина)
    Stateful-бины автоматически сохраняют свое состояние между разными клиентскими вызовами. Типичным примером stateful-бина является корзина в интернет-магазине.
    Bean Factory и Application context
    SpEL
    Способы внедрения (конструктор, метод, сеттер, field)
    Анотации @Autowired  @Inject @Resource
    Анотация @Qualifier @Named
    Анотация @Value
    Анотация @Component @Controller (MVC) @Repository @Service
    @Configuration (@Bean)
    AOP что такое? @AspectJ конфигурировнаие
    Proxy (Стандарт JDK (интерфейс) vs cglib) Плюсы минусы, что такое
    :Data
    SQLException и своя иерархия исключений в Spring
    GNDI с БД и пулл соедененний
    JDBC и JDBC Template в Spring. HibernateTemplate(Нерекомендуется к использованию)
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
XML
    XML Schema, методы описания (DTD, Schema); XSL
    DOM, SAX, STAX
    XPath
    XSLT, XQuery
    JAXB (DOM, SAX, STAX) - Серриализация java класса
    XML: DOM SAX (JAXPI.JAXB) jms jmx/ xpath (xquery)
---  BLOB. Batch
     JSON Web Token
*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
WEB (Сети)
    URI / URL
    Model OSI, TCP/IP
    HTTP 1.0 / 2.0
    RPC
    Web-Socket
    Сетевые протоколы верхнего уровня – HTTP, FTP, SMTP, POP
    Принципы работы сервлет-контейнеров, жизненные циклы, диаграммы обработки запросов
    Общие принципы обработки HTTP-запросов, защита от повторных посылок данных и т.п.
    Общие принципы защиты от взломов (SQL injections и т.п.)
    Сети как связан TCP handshake и метод Accept();

*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Тестирование
    hamcrest TDD. JUnit. Mockito

*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************
Серверы, контейнеры:
jetty
tomcat
nginx

*************************************************************************************************************************************************************************************
*************************************************************************************************************************************************************************************

JNI


Математические задачи:
1 Задачи про песочные часы При помощи только 4- и 7-минутных песочных часов точно отмерьте девять минут
2 Есть числа от 1,2,3.. 31, каждое число встречается один раз. Задача: разбить на группы так, чтобы максимальное число в группе было равно сумме остальных чисел в группе. Повторное использование чисел запрещено. Использовать нужно все числа.
3 В офисе расположили 3 автомата с различными напитками. В первом – кофе, во втором – чай, а в третьем – и кофе, и чай (выдает случайным образом). Для любого из них нужна 1 монета. Каждый автомат обозначен наклейкой с названием продукта, который он выдаёт. Вот только на заводе перепутали наклейки, и на КАЖДОМ из трех автоматов оказалась неправильная. За сколько монет можно выяснить, где какой автомат? { пф это ж изи задача, она еще называется про коробки и мячики

Задачи на многопточность
1 Написать дедлок
2 Устроить пинг понг между потоками 2 потоками
3 что будет если вот так сделать: new TreeMap().put(new Object(), new Object())
4 сделать блокирующую очередь фиксированного размера


----------
каждый программист должен быть знаком с содержимым пакетов java.lang, java.util и в меньшей степени java.io. Остальные библиотеки изучаются по мере необходимости.


{Примитивы не являются потокобезопасными.
есть три способа, которыми они небезопасны:long и double даже не гарантируется обновление атомарно (вы можете увидеть половину записи из другого потока)
модель памяти не гарантирует, что вы увидите последние обновления из одного потока в другом потоке, без каких-либо дополнительных барьеров памяти
акт приращения переменной не является атомарным в любом случае
использовать AtomicInteger etc для поток-безопасных деятельностей.}

------------
{Вопрос стандартный на собесе:
 final class A {
   private int i;
   public A(int i) {
      this.i = i;
   }
   public int getI(){
     return i;
  }
}
является ли клас потокобезопасным?  так там не намека на синхронайзд, ну файнал и ще // неизменный класс // Потокобезопасные классы инкапсулируют любую необходимую синхронизацию // Неизменяемый объект-это объект, состояние которого не изменится после его создания.
Таким образом, неизменяемые объекты всегда потокобезопасны, но их ссылки могут не быть. Чтобы сделать их ссылки потокобезопасными, нам может потребоваться получить к ним доступ из синхронизированных блоков/методов.
Может до отработки конструктора в метод гет войти? Ответ ДА. JMM не горонтирует HB между ними.
-открывай JMM и показывай, что конструктор выполняется раньше геттера
-есть HB по присвоению в int дефолтного 0
-есть HB по инициализация final или записи в volatile
-и если ты откроешь jcstress тесты jdk, на это даже отдельный тест есть
-Может до отработки конструктора в метод гет войти?
-да
----------------
hard:
3 этап - вращался вокруг задачи: надо написать рест сервис, который на вход получает url оч длинный типа
mysuperservice.com/search/12345/param1=123&param2=456...
а возвращает короткий урл типа
shortlink.com/DF4OE42                                           //  решение с редисом, вместо транзакций флажки, и ограничить глубину там до какого-то размера

---------------
сделать ArrayList, который умеет считать, сколько в него положили всего объектов за его время жизни. То есть кладут, удаляют, кладут, а он считает /// Есть класс какой-то либы. Например ArrayList. И вас просят сделать таску, например: надо посчитать количество элементов, которые положили в лист за все его время жизни. То есть могу класть, могут удалять, а нужен метод, который вернет, сколько всего объектов в него положили. Как это лучше всего реализовать?  list = new ArrayList();
и надо что-то типа list.getAddedCount() ----------------> делегирование/композиция самый норм вариант
-наследование как решение имеет одну неявную проблему
-да вполне себе явную оно имеет
-не, я имею ввиду у тебя не получится например в одном месте юзнуть свой кастом лист у которого под капотом эрэйлист, а в другом месте под капот сунуть линкед лист например
-придется еще раз то же самое написать))
-лучше, композиция слеш делегирование
MyList implements List {
   private ArrayList delegate;

   @Override
   public void add(Object o) {
     delegate.add(o);
     counter++;
   }
если addAll не вызывает add, то все будет работать правильно. Но это же сторонняя либа. Если в 12 джавке они напишут что addAll вызывает в цикле add, то твой счетчик удвоится
проблема в том, что ты меняешь дефолтное поведение методов. И не знаешь, как эти методы используются самой либой.
а с композицией ты поведение не меняешь и избешаешь сайд эффектов всегда
} вопрос закрыт!

--------------

Заметим, что массив ненулевой длины всегда является изменяемым. Поэтому практически никогда нельзя объявлять поле массива как public static final;недопустимо также создавать метод доступа, возвращающий ссылку на внутренний массив
как создать неизменяемый список -> List ->public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
Публичные поля плохо Поскольку доступ к таким классам осуществляется через поле данных, они лишены преимуществ инкапсуляции (статья 13). Вы не можете поменять структуру такого класса, не изменив его API. Вы не можете обеспечивать никакие инварианты. Вы также не можете предпринять каких-либо дополнительных действий, когда меняется значение поля
Иногда сочетание композиции и переадресации ошибочно называют делегированием (delegation). Однако формально назвать это делегированием нельзя, если только объект-оболочка не передаёт себя «обёрнутому» объекту
двоичной совместимости (binary compatibility)
(public helper class)

основное правило: схема PECS (производитель —xtends, потребитель — super). И помните, что все объекты Comparable и Comparator являются потребителями
class loader // singleton и clasloader // jee classloader


Метод, обладающий таким свойством, называют атомарным по отношению к сбоям (failure atomic).
Всегда используйте идиому цикла ожидания для вызова метода wait; никогда не вызывайте его вне цикла
несколько уровней потокобезопасности
________________________________________

fluent interface java
type inference (так же в лябдах как в Java сделаны)
Декомпиляция, офускатор (что бы не возможно было посмотреть байт код)-перемешивет как то байткод что приложение работает так же, а декомпиляция приводит к чудовищномы

В цикле for-each мы не можем модифицировать коллекцию, с другой стороны, она создает исключение ConcurrentModificationException с итератором, который мы можем модифицировать коллекцией.
Серриализация в JS. JSON parse его на Java

Во время де-сериализации объекта класс, ответственный за де-сериализацию объекта, создает экземпляр сериализованного класса, а затем переходит к заполнению сериализованных полей и свойств только после получения экземпляра для заполнения. Вы можете сделать свой конструктор private или internal, если хотите, до тех пор, пока его без параметров. https://ru.stackoverflow.com/questions/437213/objectoutputstream-vs-fileoutputstream-%D0%B8-%D1%81%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F-serialversionuid
при сериализации класса, имплементирующего Serializable настоятельно рекомендуется указывать serialVersionUID


Thread group interupt(); java у гослинга описано хорошо // это не особенно популярно + шаблон Listner (много товарищей слушают одного когда я хочу товарищам сообщить я одному сообщаю он сообщает дальше и мне на товарищей не надо хранить ссылки  )
RentrackLock класс это немного улучшеный wait notify notifyall // В чем одна из проблем wait set один ->любой поток который ждет на данном мониторе поподает в одно какое то место, когда говорим notifyall() то все просыпается, когда notify() просыпается случайный. Для блокирующей очереди шаблон производитель потрибитель, проиводитель ждет что бы задачу положить а потребитель что бы забрать

модификатор static создается один раз при инициализации объекта ///       его можно использовать самостоятельно без ссылки на конкретный экземпляр.  В этом случае он становится доступен до создания каких-либо объектов его класса и без ссылки на какой-либо объект. Статическими могут быть и переменные и методы.////Статический блок кода выполняется только один раз, когда класс загружается в память Действительно, его задача - сделать переменную или метод "независимыми" от объекта. https://javadevblog.com/chto-takoe-static-v-java-staticheskie-metody-peremenny-e-staticheskij-blok-i-java-klass.html
c java 8 можем использовтаь статические методы в интерфейсах

Переопределение toString() хороший тон. Нужен для логирования и в каком состояние был объект когда вылетело исключение.
Переопредеялять только те класы которые вы лоируете, но некоторые говорят переопределять только value классы это класс который представляет из себя какоето значение Пример: Data, Entity.

Минимизируйте accessability. Поля private. Уровень доступа минимален.
Уровни доступа к классу:  не могут быть protected и private. Внутрении классы (inner class) могут. Можем сделать поле так же protected  если private будет мешаь тестам.
public поле это лучше деалть константу public imuteble(final).
Абстрактный класс может иметь конструктор.

immutable class: класс должен быть финальный, поля приватные, отсутсвие гетеров сеторов, не возвращаем mutable objects. Такие классы потокобезопасны, удобны для кэширования (не надо создовать нове объекты, т.е. взяли поместили в память и все они там лежат не надо выделять новую память) Пример такого класса String

Чем интерфейсы лучше абстрактных классов? Первая причина интерфейсами можно расширять класс который уже существует. А клссс абстрактный может быть только один. Абстрактные классы хороши для скилетонов пример ArrayList скилетон abstarctCollection  class

Анотация @SuppressWarnings лучше не использовать или если уж используем то область видимости ограничить на минимальную типо не класс а метод

Валидация параметров метода, обычно с тех которые приходят с DTO для проверки на null итп.

---------------
Программа от Головача

...Аппаратное обеспечение
........компоненты: процессор, память, шины, контроллеры
........регистры, биты/байты/слова
........архитектура системы
........роль операционной системы
....Операционная система Linux
........ядро, устройства, драйверы
........файловая система
........процессы, сигналы, потоки
........безопастность, user management
........понятие о программировании на bash
........сети, удаленный доступ, ssh
........кластер, облако, виртуализация
....Сети
........IP, TCP, UDP
........telnet, FTP, DNS, SMTP/POP3

....Основы Java (терминология, управляющие конструкции, числа, битовые операции, массивы, строки)
....Базовые алгоритмы (итеративные алгоритмы, рекурсия, рекурсивные алгоритмы, динамические структуры данных, память в Java)
....Исключения (try-catch-finally, проверяемые / непроверяемые, стратегии обработки, try-with-resources, важные исключения в JDK)
....Ввод/вывод (кодировки, I/O Streams ,Serialization API, файловая система, NIO, NIO.2)
....Многопоточность (физический уровень, Thread / Runnable, JMM, volatile, synchronized, wait/notify, прерывание потока, java.util.concurrent.*, CompletableFuture, Executor)
....Коллекции (O-нотация, Базовая иерархия (сollection, Set, List, Map), Iterable/Iterator, foreach, ArrayList/LinkedList, equals(), HashMap/HashSet, hashCode(), TreeSet/TreeMap, Comparable/Comparator)
....ООП (понятие о типе (ClassCastException, instanceOf, java.lang.Class), конструирование объектов, сущности (class, interface, abstract class, enum), методы (overloading, overriding, hiding), области видимости (модификаторы доступа, пакеты), внутренние/вложенные, анонимные классы)
....Основные шаблоны проектирования (Builder, Singleton, Factory Method, Adapter, Decorator, Composite, Facade, Proxy, Command, Iterator, Listener, Strategy, Template Method).
....Продвинутые возможности (Reflection API, аннотации, генерики, загрузка классов)
....Java 8 (методы в интерфейсах и ссылки на методы, Лямбды (Project Lambda), Stream API, функциональные алгоритмы)

3. Программа курса «Server-side Java programming (Junior Java Developer)»
....протокол HTTP 1.1
........Methods, status codes, headers
........Persistent connection, pipelining
........Chunked encoding
........Caching, encription, compression
........основы REST
........Архитектура простейшего многопоточного HTTP-сервера на Java
....Servlet API 3.0 (Tomcat)
........шаблон MVC
........HttpServlet, HttpServletRequest, HttpServletResponse
........Dependency Injection / Inversion-of-Control framework (Spring)
....Доступ к реляционным базам данных (JDBC 4.1)
........соединяемся с базой данных (JDBC URL, Driver, Connection, DriverManager, DataSource, Типы JDBC драйверов)
........делаем запрос (Statement, ResultSet, SQLException, SQLWarning, SQLTransientException, делаем SELECT, INSERT, UPDATE, DELETE)
........шаблон DAO (cуть шаблона, generic-предок, рекурсивное объединение, альтернативы (Transaction Script, Active Record, ORM))
........PreparedStatement (оптимизация, SQL injection)
........Трюки (Пакетное обновление (batch update), извлечение сгенерированных ключей, режимы работы ResultSet (прокрутка (scroll), обновление (update)))
........Транзакции (свойства ACID, Connection.commit()/.rollback()/.setAutoCommit(), savepoint)
........Уровнип изолированности транзакций (READ UNCOMMITED, «феномен» Dirty Read, READ COMMITED, «феномен» NonRepeatable Read, REPEATABLE READ, «феномен» Phantom Read, SERIALIZABLE)
........Менеджер транзакций (Transaction manager)
........Пул соединений (JDBC connection pool)
....основы ORM (Hibernate или OpenJPA)
........Objects vs Relations
........Caching
....Test-driven development
........JUnit
........Mockito
....Инфраструктура
........система контроля версий Git
........логгирование с помощью Log4j
........сборка проекта, зависимости, тестирование с помощью Maven

4. Программа курса «Базы данных (MySQL, MongoDB, Riak)»
....Реляционные базы данных (MySQL)
........MySQL
............Устанавливаем, администрируем
............Физическая организация данных
........язык SQL
............реляционная алгебра, реляционное исчисление
............SQL types, CREATE/ALTER/DELETE table
............INSERT, UPDATE, DELETE
............SELECT, HAVING/GROUP BY, подзапросы,
........Логическое проектирование
............ER-моделирование
............Нормальные формы, денормализация
............Целостность данных
............Транзакции
........Физическое проектирование
............Индексы
............Блокировки
....Документно-ориентированные (MongoDB)
........архитектура и особенности MongoDB
........работаем с MongoDB на Java
....Key-value хранилища (Riak)
........архитектура и особенности Riak
........работаем с Riak на Java

5. Программа курса «Основы front-end разработки» (тут программу надо проработать)
....HTML
....CSS
........структура и организация CSS
........CSS frameworks
....JavaScript
........основы языка JavaScript
........работа с DOM
........библиотека jQuery

---------------------------------------------------------
При изучении concurrency golovach советовал

блокировки:
jsr 133
		/*synchronized разобраться
			synch онулирует действие кэшей, захватывает блокирову,

jmm



-dekker lock
-petterson lock
(можно ли с переменных убрать volatile)
volatile около 200 тактов потомучто запись в основную память

---
Double-checked looking is Brooken Declaration (dlc)
+ прочитать тоже самое статью By Brain Goetz (javaWorld)
---
Шепелево посмотреть
---
https://shipilev.net
http://gee.cs.oswego.edu/dl/jmm/cookbook
https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html
-----
ps: 00021zebilxxxsuroh (z-kapsom kstati)
-----
///////////////
SERIALIZABLE=> могу сериализовать на одном языке, а десириализововать на другом
jdbc pattern
